#!/usr/bin/env ruby

require "active_support"
require "active_support/core_ext/numeric/bytes"
require "opensearch/audit"
require "opensearch/cli"

options = {
  min_index_size: 10.gigabytes,
  max_index_size: 50.gigabytes
}

cli = OpenSearch::CLI.new do |opts|
  opts.banner = "Usage: #{$PROGRAM_NAME} [options]"

  opts.on("-p", "--profile=PROFILE", [:read, :write], "Select a workload profile (read, write)") do |profile|
    if profile == :read
      options[:min_index_size] = 10.gigabytes
      options[:max_index_size] = 30.gigabytes
    elsif profile == :write
      options[:min_index_size] = 30.gigabytes
      options[:max_index_size] = 50.gigabytes
    end
  end
end

cli.load
cli.parse!

index_param = ARGV.first || "_all"

indices = cli.client.cat.indices(index: index_param, format: "json", bytes: "b", s: "index")

all_indices_stats = Hash.new { |hash, key| hash[key] = OpenSearch::Audit::IndexGroup.new }

indices.each do |index|
  name = OpenSearch::Audit::IndexName.new(index)
  next unless name.periodic?

  all_indices_stats[name.base_name].add(index)
end

puts "Found indices:"
all_indices_stats.each do |name, stats|
  trends = [14, 7].map do |days|
    format("%<trend>9s (%<days>d days)",
      trend: ActiveSupport::NumberHelper.number_to_human_size(stats.median_trend(days)),
      days: days)
  end.join(", ")
  puts format("%<count>4d x %<name>-20s %<median>9s [min: %<min>9s max: %<max>9s, trends: %<trends>s]\n",
    count: stats.count,
    name: name,
    median: ActiveSupport::NumberHelper.number_to_human_size(stats.median),
    min: ActiveSupport::NumberHelper.number_to_human_size(stats.min),
    max: ActiveSupport::NumberHelper.number_to_human_size(stats.max),
    trends: trends)
end

# Check shard size
# https://opensearch.org/blog/optimize-opensearch-index-shard-size/
all_indices_stats.each do |name, stats|
  if stats.median < options[:min_index_size]
    warn format("Indices %<index>s are too small (%<size>s < %<ref>s).  Consider reducing the number of shards by index or merging indices.",
      index: name,
      size: ActiveSupport::NumberHelper.number_to_human_size(stats.median),
      ref: ActiveSupport::NumberHelper.number_to_human_size(options[:min_index_size]))
  elsif stats.median > options[:max_index_size]
    warn format("Indices %<index>s are too big (%<size>s > %<ref>s).  Consider adding more shards by index.",
      index: name,
      size: ActiveSupport::NumberHelper.number_to_human_size(stats.median),
      ref: ActiveSupport::NumberHelper.number_to_human_size(options[:max_index_size]))
  end
end

def dynamic_mapping?(mapping, key: [])
  return false unless mapping.is_a?(Hash)

  result = false

  if mapping["type"] == "keyword" && mapping["ignore_above"] == 256
    warn "Field #{key.join(".")} looks like a dynamic field to me"
    result = true
  else
    mapping.each do |k, v|
      result = true if dynamic_mapping?(v, key: key + [k])
    end
  end

  result
end

mappings = cli.client.indices.get_mapping(index: index_param)

mappings.each do |index, mapping|
  if dynamic_mapping?(mapping)
    warn "Index #{index} seems to have dynamic mapping"
  end
end
